# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/187rXRLw3Ib9TQDhXRBFNkt7xSDoQURYa
"""

!pip install svgwrite cairosvg

import numpy as np
import matplotlib.pyplot as plt
import svgwrite
import cairosvg
from PIL import Image
import matplotlib.image as mpimg
import re
from google.colab import files

# Define test case groups
test_cases_borders = ['frag0.csv', 'frag0_sol.csv', 'frag1.csv', 'frag2.csv', 'frag2_sol.csv', 'isolated.csv', 'isolated_sol.csv', 'occlusion1_rec.csv']
test_cases_polygon = ['occlusion1.csv', 'occlusion1_sol.csv', 'occlusion2.csv', 'occlusion2_sol.csv']

# Function to read and parse the CSV file into paths
def parse_csv_to_paths(csv_path):
    data = np.genfromtxt(csv_path, delimiter=',')
    paths = []
    for group_id in np.unique(data[:, 0]):
        group_data = data[data[:, 0] == group_id][:, 1:]
        group_paths = []
        for sub_id in np.unique(group_data[:, 0]):
            path = group_data[group_data[:, 0] == sub_id][:, 1:]
            group_paths.append(path)
        paths.append(group_paths)
    return paths

# Function to render paths as filled polygons in a plot
def render_filled_polygons(paths, colors):
    fig, ax = plt.subplots(tight_layout=True, figsize=(8, 8))
    for i, path_group in enumerate(paths):
        color = colors[i % len(colors)]
        for path in path_group:
            ax.fill(path[:, 0], path[:, 1], c=color, edgecolor='black', linewidth=2)  # Fill the polygon with color
    ax.set_aspect('equal')
    plt.gca().invert_yaxis()
    plt.show()

# Function to render paths as border lines in a plot
def render_bordered_paths(paths, colors):
    fig, ax = plt.subplots(tight_layout=True, figsize=(8, 8))
    for i, path_group in enumerate(paths):
        color = colors[i % len(colors)]
        for path in path_group:
            ax.plot(path[:, 0], path[:, 1], c=color, linewidth=2)  # Plot the border line
    ax.set_aspect('equal')
    plt.gca().invert_yaxis()  # Invert y-axis to match the SVG coordinate system
    plt.show()

# Function to convert paths to an SVG image and save as PNG
def paths_to_svg(paths, svg_filename, colors):
    # Calculate width and height for the SVG canvas
    max_width, max_height = 0, 0
    for path_group in paths:
        for path in path_group:
            max_width = max(max_width, np.max(path[:, 0]))
            max_height = max(max_height, np.max(path[:, 1]))
    padding = 0.1
    width, height = int(max_width + padding * max_width), int(max_height + padding * max_height)

    # Create an SVG drawing object
    drawing = svgwrite.Drawing(svg_filename, profile='tiny', shape_rendering='crispEdges')
    group = drawing.g()

    # Add paths to the SVG
    for i, path_group in enumerate(paths):
        path_data = ""
        color = colors[i % len(colors)]
        for path in path_group:
            path_data += f"M {path[0, 0]} {path[0, 1]} "
            for point in path[1:]:
                path_data += f"L {point[0]} {point[1]} "
            path_data += "Z"  # Ensure the path is closed
        group.add(drawing.path(d=path_data.strip(), fill=color, stroke='black', stroke_width=2))

    # Save SVG and convert to PNG
    drawing.add(group)
    drawing.save()
    png_filename = svg_filename.replace('.svg', '.png')
    scale_factor = max(1, 1024 // min(height, width))
    cairosvg.svg2png(url=svg_filename, write_to=png_filename, parent_width=width, parent_height=height,
                     output_width=scale_factor * width, output_height=scale_factor * height, background_color='white')

# Function to handle polygon CSV files
def process_polygon_csv(csv_filename, colors):
    paths = parse_csv_to_paths(csv_filename)
    render_filled_polygons(paths, colors)
    output_svg_path = csv_filename.replace('.csv', '.svg')
    paths_to_svg(paths, output_svg_path, colors)

# Function to handle border CSV files
def process_border_csv(csv_filename, colors):
    paths = parse_csv_to_paths(csv_filename)
    render_bordered_paths(paths, colors)
    output_svg_path = csv_filename.replace('.csv', '.svg')
    paths_to_svg(paths, output_svg_path, colors)

# Main processing function
def process_uploaded_files(uploaded_files):
    for filename in uploaded_files.keys():
        formatted_filename = re.sub(r'\s\(\d+\)', '', filename)
        print(f"Processing file: {formatted_filename}")

        if formatted_filename in test_cases_borders:
            if formatted_filename in ['frag0.csv', 'frag1.csv', 'frag2.csv']:
                colors = ['black']
                process_border_csv(filename, colors)
            elif formatted_filename == 'isolated_sol.csv':
                colors = ['red']
                process_border_csv(filename, colors)
            elif formatted_filename == 'frag0_sol.csv':
                colors = ['yellow']
                process_border_csv(filename, colors)
            elif formatted_filename in ['occlusion1_rec.csv', 'occlusion1_sol_rec.csv']:
                img = mpimg.imread(formatted_filename)
                plt.imshow(img)
                plt.axis('off')  # Hide the axes
                plt.show()

        elif formatted_filename in test_cases_polygon:
            if formatted_filename in ['occlusion1.csv', 'occlusion1_sol.csv']:
                colors = ['yellow', 'lightgreen']
                process_polygon_csv(filename, colors)
            elif formatted_filename in ['occlusion2.csv', 'occlusion2_sol.csv']:
                colors = ['white']
                process_polygon_csv(filename, colors)
        else:
            print(f"Unknown file type: {formatted_filename}. No processing performed.")

# Upload files and process them
uploaded = files.upload()
print("Uploaded files:", uploaded.keys())
process_uploaded_files(uploaded)